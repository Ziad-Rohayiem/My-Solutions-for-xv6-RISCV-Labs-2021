1) a0, a1..., a7 contain arguments to functions. In this case, it is a2 that holds 13.

2) The compiler directly calculates the result of "f(8)+1 = 12" and stores it in a1.

3) 0000000000000630 <printf>:

4) 34:	600080e7          jalr	1536(ra) # 630 <printf>
   exit(0);
   38:	4501              li	a0,0
   
   ,So in this case the value in ra after jalr to printf is 0x38.
   
5) Output: He110 World.
   when RISC-V is big-endian, i = dlr.
   And since 57616 is always 0xe110 no matter the RISC-V is little-endian or big-endian,
   we donâ€™t need to change 57616 to a different value.
   
6) The value of y printed is undefined because, before calling printf,
   the compiler assigns input parameters to registers a0-a7. When printf is executed,
   these values are read from the registers. As the second placeholder isn't specified, a2 remains unchanged.
   Consequently, the printed value of y is arbitrary and reflects whatever was in a2 before the function call.
